//? BASE ====================================================================================================//

// font-weight Устанавливает насыщенность шрифта ===============//

//100 - thin
//200 - UltraLite
//300 - lite
//400 - normal
//500 - medium
//600 - semibold
//700 - bold
//800 - Heavy
//900 - black

//Шрифты, встроенные в Windows===============//

//Times New Roman
//Georgia
//Arial
//Arial Black
//Tahoma
//Verdana
//Trebuchet MS
//Lucida Sans Unicode
//Impact
//Comic Sans MS
//Courier New
//Lucida Console

// font-style ===============//

//font-style: Определяет начертание шрифта — обычное, курсивное или наклонное.
//	normal - Обычное начертание текста.
//	italic - Курсивное начертание. 
//	oblique - Наклонное начертание. Курсив и наклонный шрифт при всей их похожести не одно и то же.
//	Курсив это специальный шрифт имитирующий рукописный, наклонный же образуется путем наклона обычных знаков вправо.


// text-transform ===============//

//text-transform  Управляет преобразованием текста в заглавные или прописные символы.
//	capitalize  - Первый символ каждого слова в предложении будет заглавным. Остальные символы свой вид не меняют.
//	lowercase -   Все символы текста становятся строчными (нижний регистр). 
//	uppercase -   Все символы текста становятся прописными (верхний регистр).
//	none -        Не меняет регистр символов.

//text-indent Устанавливает величину отступа первой строки блока текста. Применяется, если нам нужно создать что-то типа красной строки.
//word-spacing Устанавливает интервал между словами.

//white-space Управляет свойствами пробелов между словами. Пименяется в основном со значением 
//	nowrap которое запрещает перенос строки. Таким образом весь текст отображается в одну строку и не ломается.  
//	normal вернет все как было.


// box-sizing ===============//

//Применяется для изменения алгоритма расчета ширины и высоты элемента. 
//Свойство наследуется.
//content-box - Основывается на стандартах CSS, при этом свойства width и height задают ширину и высоту контента и не включают в себя значения отступов, полей и границ.
//border-box -  Свойства width и height включают в себя значения полей и границ, но не отступов (margin). Эта модель используется браузером Internet Exporer в режиме несовместимости.
//padding-box - Свойства width и height включают в себя значения полей, но не отступов (margin) и границ (border). 

//font-size, font-family, font-style, font-weight, color, text-align, text-transform, text-indent, line-height, letter-spacing, word-spacing, white-space, direction и другие.
//Также к наследуемым свойствам относятся list-style, cursor, visibility, border-collapse и некоторые другие. Но они используются значительно реже.


//? CSS селекторы ====================================================================================================//
/*
CSS селекторы     https://htmlbase.ru/article/css-selektory

Типы селекторов

Универсальный селектор ‘*’ Указывает на все элементы на странице
Селекторы тегов ‘body, div, p, ...’
Селектор по классу ‘.class-name’
Селектор по идентификатору ‘#id-name’  Имя идентификатора должно быть уникальным на странице!   ( #block { } )

Селекторы по атрибуту ‘p[class]’
p[class="text"] { } все параграфы у которых указан только один класс с именем ‘text’
p[class~="text"] { } все параграфы у которых в названии класса есть слово 'text'
p[class^="text"] { } все параграфы у которых класс ‘text’ указан первый или первый с префиксом ‘text-’
p[class$="text"] { } все параграфы у которых класс ‘text’ указан последний
p[class|="text"] { } все параграфы у которых указан только один класс с именем ‘text’ или с префиксом ‘text-’
p[class*="text"] { } все параграфы у которых в названии класса есть подстрока ‘text’
Если добавить символ 'i' перед закрывающейся скобкой, то значение атрибута сравнивается без учета регистра. 
a[href="link" i] { } все ссылки у которых указан атрибут href=”link”, в котором ссылка может быть в любом регистре. * Не работает в IE

Комбинирование селекторов
Можно указать сразу несколько селекторов без пробелов чтобы получить элемент по нескольким критериям.
p.text#text { }все параграфы у которых указан класс и идентификатор с именем ‘text’

Отношение селекторов
.wrapper .block { } все элементы с классом ‘block’ являющееся потомками элемента с классом ‘wrapper’
.wrapper > .block { } все элементы с классом ‘block’ являющееся непосредственными потомками элемента с классом ‘wrapper’
.wrapper ~ .block { } все элементы с классом ‘block’, которые расположенные после элемента с классом ‘wrapper’ на том же уровне
.wrapper + .block { } первый элемент с классом ‘block’, который расположен после элемента с классом wrapper на том же уровне

Выбор псевдоэлемента
Для выбора псевдоэлемента используется ::
selector::pseudo-element { }
p::before { } задать стили для псевдоэлемента before у параграфа

Выбор псевдокласса
Для выбора псевдокласса используется :
div:first-child { } задание стилей для первого потомка div
div:hover { } задание стилей для div при наведении


//? Псевдоклассы ====================================================================================================//

Селектор:Псевдокласс { параметры стиля }

	:hover Срабатывает при наведении на элемент, часто применяется применяется как для ссылок так и для любого другого элемента.
	:active Срабатывает при нажатии на элемент. В основном применяется к ссылкам и кнопкам.
	:visited Срабатывает для посещенных ссылок
	:focus Срабатывает при получении элементом фокуса. Часто применяется к елементам форм. Например инпутам.
	:first-child Обращение к первому элементу в блоке
	:last-child Обращение к последнему элементу в блоке
	:nth-child(порядковый номер элемента) Обращение к конкретным элементам в блоке
	odd - Обращается к элементам с нечётными номерами
	even - Обращается к элементам с чётными номерами

	//? Псевдоэлемент ====================================================================================================//
	
	Псевдоэлементы – это селекторы, которые определяют область элементов, которая изначально отсутствует в дереве документа. Эта область создается искусственно с помощью CSS.
	
	:first-line задает стиль первой строки форматированного текста. 
	Длина этой строки зависит от многих факторов, таких как используемый шрифт,размер окна браузера, ширина блока, языка и т.д. 
	В правилах стиля допустимо использовать только свойства, относящиеся к шрифту, изменению цвета текста и фона.
 
	:first-letter определяет стиль первого символа в тексте элемента, к которому добавляется. 
	К этому псевдоэлементу могут применяться только стилевые свойства, связанные со свойствами шрифта, полями, отступами, границами, цветом и фоном.
 
	:before применяется для отображения желаемого контента до содержимого элемента, к которому он добавляется. Работает совместно со свойством content. 
	При добавлении :before к блочному элементу, значение свойства display может быть только: block, inline, none, list-item. Все остальные значения будут трактоваться как block.
	При добавлении :before к встроенному элементу, display ограничен значениями inline и none. 
	Все остальные будут восприниматься как inline.
 
	Псевдоэлемент, который используется для вывода желаемого текста после содержимого элемента, к которому он добавляется.
	Псевдоэлемент :after работает совместно со свойством content.

	:after к блочному элементу, значение свойства display может быть только: 
	block, inline, none, list-item. Все остальные значения будут трактоваться как block.
	При добавлении :after к встроенному элементу, display ограничен значениями inline и none. Все остальные будут восприниматься как inline.
 
	::-ms-clear {} Задаёт стиль кнопки для очистки текстового поля. Исходно эта кнопка не видна, она появляется в правой части поля только при вводе текста.Только IE (интернет эксплоуер) 
	::-moz-focus-inner{} Задаёт стиль внутренней части элемента Только FireFox


//? Условия медиазапросов (@media) ====================================================================================================//

Тип устройства:
all 	Подходит для всех типов устройств.
print 	Предназначен для страничных материалов и документов, просматриваемых на экране в режиме предварительного просмотра печати.
screen 	Предназначен в первую очередь для экранов цветных компьютерных мониторов.
speech 	Предназначен для синтезаторов речи.

Характеристики устройства:
width Проверяет ширину области просмотра. Значения задаются в единицах длины, px, em и т.д., например, (width: 800px). 
Обычно для проверки используются минимальные и максимальные значения ширины.

min-width Применяет правило если ширина области просмотра больше значения, указанного в запросе, max-width — ширина области просмотра меньше значения, указанного в запросе.

height 	Проверяет высоту области просмотра. Значения задаются в единицах длины, px, em и т.д., например, (height: 500px). 
Обычно для проверки используются минимальные и максимальные значения высоты.

min-height      Применяет правило если высота области просмотра больше значения, указанного в запросе, 
max-height — высота области просмотра которого меньше значения, указанного в запросе.

aspect-ratio   Проверяет соотношение ширины к высоте области просмотра. 
Широкоэкранный дисплей с соотношением сторон 16:9 может быть помечен как (aspect-ratio: 16/9).

min-aspect-ratio проверяет минимальное соотношение, 
max-aspect-ratio — максимальное соотношение ширины к высоте области просмотра.

orientation   Проверяет ориентацию области просмотра. Принимает два значения: (orientation: portrait) и (orientation: landscape).

resolution    Проверяет разрешение экрана (количество пикселей). 
Значения также могут проверять количество точек на дюйм (dpi) или количество точек на сантиметр (dpcm), например, (resolution: 300dpi).

min-resolution проверяет минимальное разрешение экрана, 
max-resolution — максимальное.

color     Проверяет количество бит на каждый из цветовых компонентов устройства вывода. 
Например, (min-color: 4) означает, что экран конкретного устройства должен иметь 4-битную глубину цвета.

min-color проверяет минимальное количество бит, 
max-color — максимальное количество бит.

color-index     Проверяет количество записей в таблице подстановки цветов. 
В качестве значения указывается положительное число, например, (color-index: 256).

min-color-index проверяет минимальное количество записей, 
max-color-index — максимальное количество записей.

monochrome     Проверяет количество битов на пиксель монохромного устройства. 
Значение задается целым положительным числом, например, (min-monochrome: 8).

min-monochrome проверяет минимальное количество битов, 
max-monochrome — максимальное количество битов.

-webkit-device-pixel-ratio   Задаёт количество физических пикселей устройства на каждый CSS-пиксель.


//? CSS переходы ====================================================================================================//

CSS переходы (CSS transition)      https://fls.guru/csstransition.html

Что такое CSS переходы?
CSS – переходы либо CSS – transitions могут применяться ко всем элементам и даже к псевдоэлементам. 
Используются для оживления верстки, что в свою очередь приводит к улучшению взаимодействия с пользователем, 
как правило путем приятной анимированной реакции на его действия. Например – наведение и нажатие на кнопку. 
Также свойства transition можно использовать для построения несложных сценариев анимации. 
Фактически, CSS – переходы обеспечивают смену значений других свойств с определенной анимацей и сценарием. 
Всю эту магию можно описать универсальным CSS свойством transition, либо рядом следующих отдельных свойств:

Transition-duration Определяет промежуток времени, в течение которого должен осуществляться переход. 
Собственно – тут мы указываем время за которое одно значение свойства по переходит (анимируется) в другое. Свойство не наследуется.
transition-duration: 1s;  Анимация при смене значений свойств будет происходить за 1 секунду

Transition-property  Содержит название CSS-свойств, к которым будет применен эффект перехода. 
Значение свойства может содержать как одно свойство, так и список свойств через запятую. Свойство не наследуется.
transition-property: all;  по умолчанию
transition-property: background-color, top; Переход будет применен только к свойствам background-color и top

Transition-delay  Задержка выполнения перехода. Позволяет сделать так, чтобы изменение свойства происходило не моментально, а с некоторой задержкой. 
Время задержки перехода указывается в секундах или миллисекундах. Свойство не наследуется.
transition-delay: 0s;   по умолчанию
transition-delay: 1s;   Переход будет применен через одну секунду задержки

Transition-timing-function  Задаёт стиль нашего перехода, то есть некий сценарий, по которому будет осуществятся анимация.
transition-timing-function: ease; Переход начинается медленно, разгоняется быстро и замедляется в конце. Соответствует cubic-bezier(0.25,0.1,0.25,1).
transition-timing-function: ease-in; Переход начинается медленно, а затем плавно ускоряется в конце. Соответствует cubic-bezier(0.42,0,1,1).
transition-timing-function: ease-out; Переход начинается быстро и плавно замедляется в конце. Соответствует cubic-bezier(0,0,0.58,1).
transition-timing-function: ease-in-out; Переход медленно начинается и медленно заканчивается. Соответствует cubic-bezier(0.42,0,0.58,1).
transition-timing-function: linear; Переход происходит равномерно на протяжении всего времени, без колебаний в скорости. Соответствует cubic-bezier(0,0,1,1).
transition-timing-function: steps(2,start);   transition-timing-function: steps(2,end);  Временная функция позволяет разбить анимацию на чёткое количество шагов указанных в int.
Так же можно задать момент выполнения: Start – означает, что при начале анимации нужно сразу применить первое изменение. End - означало бы, что изменения нужно применять не в начале, а в конце каждого шага

Значения перехода для каждого свойства. Для элемента можно задать несколько последовательных переходов, перечислив их через запятую. 
Каждый переход можно оформить своими значениями перехода.
transition: background-color 1s ease 0.5s, padding 5s ease-out 0s;
ИЛИ ТО ЖЕ:
transition-property: background-color, padding;
transition-duration: 1s, 5s;
transition-delay: 0.5s, 0s;
transition-timing-function: ease, ease-out;


//? CSS анимация ====================================================================================================//

CSS анимация (CSS animation & @keyframes)  https://fls.guru/cssanimation.html

Что такое CSS анимация?
Как и CSS свойство плавных переходов transition, свойство animation призвано сделать нашу верстку более динамичной, 
оживить её для лучшего взаимодействия с пользователем и создания WOW эффекта.
Но в отличие от CSS переходов, создание анимации базируется на ключевых кадрах @keyframes, 
которые позволяют автоматически воспроизводить и повторять эффекты на протяжении заданного времени, а также приостанавливать анимацию по определенному событию.
Другими словами, использование конструкции animation и @keyframes позволяет нам создавать более сложные сценарии анимаций.

Animation-name Определяет список применяемых к элементу анимаций (ключевых кадров). Можно указать через запятую. Причем приоритет у последней записи.
	animation-name: circle; Связываем селектор animation__circle с ключевыми кадрами circle.
	animation-name: none;   Отменяем анимацию селектора animation__circle.

Animation-duration Отвечает за продолжительность анимации.
	animation-duration: 1s;          Переход будет длиться 1 секунду
	animation-duration: 2.5s;      Переход будет длиться 2.5 секунды
	animation-duration: 500ms; Переход будет длиться 500 миллисекунд

Animation-timing-function Задаёт сценарий развития анимации между ключевыми кадрами.
	animation-timing-function: ease;              Переход начинается медленно, разгоняется быстро и замедляется в конце.
	animation-timing-function: ease-in;         Переход начинается медленно, а затем плавно ускоряется в конце.
	animation-timing-function: ease-out;      Переход начинается быстро и плавно замедляется в конце.
	animation-timing-function: ease-in-out; Переход медленно начинается и медленно заканчивается.
	animation-timing-function: linear;            Переход происходит равномерно на протяжении всего времени, без колебаний в скорости.
	animation-timing-function: steps(2,start) Временная функция позволяет разбить анимацию на чёткое количество шагов указанных в int. 
Так же можно задать момент выполнения: Start – означает, что при начале анимации нужно сразу применить первое изменение. 
End - означало бы, что изменения нужно применять не в начале, а в конце каждого шага.
	
Animation-iteration-count Отвечает за повтор проигрывания ключевых кадров.
	animation-iteration-count: 1;             Ключевые кадры проиграются 1 раз.
	animation-iteration-count: 3;             Ключевые кадры проиграются 3 раза.
	animation-iteration-count: infinite; Ключевые кадры будут проигрываться бесконечно.

Animation-direction Определяет направление и тип проигрывания ключевых кадров.
	animation-direction: normal;     Ключевые кадры проиграются так, как они написаны.
	animation-direction: reverse;    Кадры будут проигрываться в обратном порядке.
	animation-direction: alternate; Каждый чётный проход по кадрам будет проигрываться в обратном порядке.
	animation-direction: alternate-reverse; Каждый нечётный проход по кадрам будет проигрываться в обратном порядке.

Animation-play-state Позволяет запускать или останавливать анимацию по событию.
	nimation-play-state: running;   Анимация проигрывается.
	animation-play-state: paused; При наведении анимация на паузе.

Animation-delay Отвечает за задержку перед проигрыванием.
	nimation-delay: 0s;    Задержки нет.
	animation-delay: 1s; Задержка 1 секунда.
	animation-delay: 200ms; Задержка 200 миллисекунд.

Animation-fill-mode Определяет какие значения анимируемых css свойств применятся к объекту после завершения анимации.
	animation-fill-mode: none; Завершится.
	animation-fill-mode: forwards;
	animation-fill-mode: backwards; 
	animation-fill-mode: both;


//? Единицы измерения CSS - PX, EM, REM, %, VW, VH, VMIN, VMAX, FR, EX, CH+++ ====================================================================================================//

https://fls.guru/css-units.html

Абсолютная единица - не зависит от значений других свойств. Ее можно назвать еще фиксированной или окончательной.
Относительная единица - зависит от того или иного значения других свойств.

	PX - пиксели - абсолютная (фиксированная) единица. Значение заданное в пикселях (px), четкое и понятное.
Как правило, в макетах дизайна мы видим размеры именно в пикселях. 
Поэтому, используя эту единицу мы легко можем переносить данные в код с точностью пиксель перфект. Это когда макетные размеры совпадают с версткой на все 100%.
Остальные единицы, так или иначе пересчитываются браузером все равно в пиксели.
Пиксели могут быть дробными, например размер можно задать в 16.5px.
Преимущества: Чёткость, понятность, простота использования. Подходит для начинающих.
Недостатки: По сравнению с другими, относительными единицами это усложняет нам работу при адаптиве, а также снижает доступность нашей верстки, запрещая пользователю менять настройки в браузере

	EM – относительна размеру шрифта Относительная единица. Размер формируется относительно текущего или унаследованного размера шрифта (font-size).
1em равен значению font-size.
Как мы знаем, свойство размера шрифта font-size наследуется потомками. Поэтому, указывая тот или иной размер в EM нужно четко понимать какой размер шрифта влияет на данный элемент.
Как и пиксели, значение EM можно указывать дробные.
Преимущества: относительность EM позволяет на порядок уменьшить кол-во действий при адаптивной верстке. 
Не ограничивает пользователя в настройках браузера. Отлично подходит для указания размеров зависящих от размера шрифта. Также используется в медиа запросах.
Недостатки: по сравнению с PX, работать с EM более сложно, ведь для переноса данных из макета в единицы в EM требуются вычисления

	REM - относительна размеру шрифта браузера Относительная единица. Размер формируется относительно размера шрифта (font-size) в теге <html> или браузера по умолчанию.
1rem равен значению font-size в теге <html> или браузера по умолчанию.
Можно указывать дробные числа, например 1.5rem
Преимущества: Относительность REM позволяет на порядок уменьшить кол-во действий при адаптивной верстке. 
Не ограничивает пользователя в настройках браузера. Более простое использование. Отлично подходит для указания размеров шрифтов.
Недостатки: По сравнению с PX, работать с REM более сложно, ведь для переноса данных из макета в единицы в REM требуются вычисления, но проще чем с EM.

	% - проценты от ...  Относительная единица. Можно указывать дробные числа, например 10.5%. Разные CSS свойства вычисляют процент относительно разных значений:
Ширина width - относительно ширины родительного элемента
Высота height - относительно высоты родительного элемента, но только если у него задана высота либо это флекс или грид элемент.
При относительном позиционировании (position: relative; + top left bottom right) нужны те же условия.
Для абсолютно позиционированных объектов - относительно высоты родительского элемента. При этом, задавать высоту родителю не обязательно.
Отступы padding \ margin - относительно ширины родительного элемента, даже если задаются вертикальные отступы.
transform: translate(x, y) - относительно ширины \ высоты самого объекта к которому применено свойство.
font-size и line-height - относительно размера свойства font-size
Преимущества: Относительность процентов позволяет на порядок уменьшить кол-во действий при адаптивной верстке. 
Не ограничивает пользователя в настройках браузера. Отлично подходит для построения относительных конструкций и позиционирования объектов.
Недостатки: Требуют хорошего знания теории и четкого понимания - процент от чего вычислятестя в тот или иной момент

	VW, VH, VMIN, VMAX - относительно окна (вьюпорта) браузера
Все они так или иначе работают относительно окна браузера, так называемого вьюпорта.
Вьюпорт, простыми словами, это вот эта рамка через которую мы просматриваем сайт.
Итак VW работает относительно ширины вьюпорта, VH относительно высоты вьюпорта.
VMIN - относительно наименьшего значения из (VW, VH). VMAX - относительно наибольшего значения из (VW, VH).
100vw равно ширине окна браузера (вьюпорта), 100vh равно высоте окна браузера (вьюпорта).
100wmin равно наименьшему из (vw, vh), 100vmax равно наибольшему из (vw, vh)
Преимущества: Относительность VW, VH, VMIN, VMAX позволяет на порядок уменьшить кол-во действий при адаптивной верстке. 
Не ограничивает пользователя в настройках браузера. Можно привязаться к размерам вьюпорта, что позволяет строить отзывчивые свойства.
Недостатки: Сложность в использовании. Нужно обладать хорошими знаниями адаптивной верстки и возможностей CSS. 
На мобильных устройствах, при работе на всю высоту вьюпорта (100vh), требуются дополнительные действия на JS.

	FR, EX, CH, MM, CM, PT, PC - прочие единицы
FR - единица измерения в модуле GRID. Указавает какую часть (фрагмент) должен занимать тот или иной грид-элемент. 
Значения могут быть дробными, например 0.5fr. Отлично работает с отступами gap
EX - единица работающая относительно размера латинского символа "x" (прописная). Используется редко
CH - единица работающая относительно размера символа "0" (ноль). Используется редко
Единицы MM, CM, PT, PC являются производными от пикселя и уже не используются

	Формулы конвертации значений из PX в относительные единицы:
из PX в EM - значение в PX поделить на значение font-size (текущее или унаследованное)
из PX в REM - значение в PX поделить на значение font-size указанное для тега HTML (если не указано то на 16)
из PX в % - значение в PX поделить на значение относительно которого высчитывается процент и умножить на 100


//? Синемантика ====================================================================================================//

Основные теги влияющие на отображение страницы

<!-- Кодировка страницы -->
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
С появлением HTML5 можно использовать 
<meta charset="UTF-8">
<!-- Настройки адаптивности страницы  -->
Фиксированная ширина
<meta name="viewport" content="width=1170">
Адаптивность
<meta name="viewport" content="width=device-width">

<!-- Отключает принудительную ссылку у номера телефона на iOS -->
<meta name="format-detection" content="telephone=no">

=================================================

SEO

<!-- Краткое описание страницы  -->
<meta name="description" content=" ">
Пишем не более 140 символов.
<!-- Ключевые слова страницы  -->
<meta name="keywords" content=" "> 
Пишем не более 20ти слов. Ключевые фразы разделяем запятой.

<!-- Управление доступом поисковых роботов к странице -->
<meta name="robots" content="">

По умолчанию страница индексируется поисковыми система, то есть этот мета тег дополнительно указывать не нужно. 
Но если задача стоит запретить либо ограничить индексацию, то существуют следующие значения:

none – запретить индексацию страницы полностью.
noindex – запретить индексацию содержимого страницы.
nofollow – игнорировать ссылки в пределах веб-страницы. 
noimageindex - запретить индексацию присутствующих на странице изображений
noarchive - запретить  вывод в результатах поиска ссылки «Сохраненная копия»
nosnippet - запретить  вывод в поисковой выдаче под названием страницы фрагмента текста, описывающего её содержание.

Значения указываются через запятую. Например:

Запрет индексации страницы полностью будет выглядеть так:
<meta name="robots" content="noindex, nofollow">
или так
<meta name="robots" content="none">

Запрет индексации ссылок и изображений на странице будет выглядеть так:
<meta name="robots" content="noimageindex, nofollow">
при этом текст страницы будет доступен к индексации.

=================================================
Технические
<!-- Автор страницы -->
<meta name="Author" content="Пупкин Василий Петрович"> 
<!-- Авторские права -->
<meta name="Copyright" content="Зимина Татьяна Юрьевна"> 
<!-- Адрес автора -->
<meta name="Address" content="Луна, кратер №97">
<!-- Редирект (перезагрузка) страницы. Задержка в секундах; url=Адрес сайта/страницы -->
<meta http-equiv="refresh" content="S; url=URL">

S= Задержка в секундах
URL= Адрес сайта/страницы

=================================================

Для социальных сетей
 
Facebook
Что бы настроить вид нашей страницы в посте мы пишем следующие мета теги:

<!-- локализация сайта, для русскоязычного сайта ru_RU -->
<meta property="og:locale" content="ru_RU">
<!-- тип контента, по умолчанию используется article -->
<meta property="og:type" content="article">
<!-- заголовок страницы, который будет выводится в записи социальной сети -->
<meta property="og:title" content="META теги">
<!-- описание страницы -->
<meta property="og:description" content="Описание страницы про META теги">
<!-- ссылка на изображение, которое будет публиковаться в записи -->
<meta property="og:image" content="http://fls.guru/meta/img/bg.jpg">
<!-- ссылка на текущую страницу -->
<meta property="og:url" content="http://fls.guru/meta/ ">
<!-- название сайта -->
<meta property="og:site_name" content="Фрилансер по жизни">

Проверить разметку можно в валидаторе от Facebook https://developers.facebook.com/tools/debug/sharing/
Подробнее о протоколе Open Graph можно почитать в официальной документации по ссылке в описании. https://ruogp.me/

Для создания Twitter Cards мета теги будут иметь другой вид:

<!-- Тип карты, по умолчанию используется summary -->
<meta name="twitter:card" content="summary">
<!-- Имя/логин автора -->
<meta name="twitter:site" content="Жека">
<!-- Название страницы -->
<meta name="twitter:title" content="META теги">
<!-- Описание страницы -->
<meta name="twitter:description" content="про META теги">
<!-- Cсылка на изображение -->
<meta name="twitter:image" content="http://fls.guru/meta/img/bg.jpg">

Проверяем результат в валидаторе твиттер 
https://cards-dev.twitter.com/validator

Подробнее о создании Twitter Cards можно почитать в официальной документации по ссылке в описании.
https://developer.twitter.com/en/docs/tweets/optimize-with-cards/guides/getting-started